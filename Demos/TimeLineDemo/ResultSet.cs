using System;
using System.Numerics;
using System.Text;
using RedGate.PrimalityTests;

namespace RedGate.Demo
{
    /// <summary>
    /// Class representing a row item in the data grid
    /// </summary>
    internal class ResultSet
    {
        // Random number generator for samples
        private static readonly Random Rnd;

        public TimeSpan Duration { get; private set; }
        public int PrimeCount { get; private set; }
        public double PrimePercentage { get; private set; }
        public int SampleSize { get; private set; }
        public ulong MaxRandom { get; private set; }
        public string Algorithm { get; private set; }

        static ResultSet()
        {
            Rnd = new Random();
        }

        /// <summary>
        /// Generate a sample of random numbers and check them for primality.
        /// </summary>
        /// <returns>A ResultSet summarizing the results</returns>
        public static ResultSet Generate(ApplicationOptions options, PrimeTable primeTable)
        {
            IPrimalityTest backupAlgorithm;
            // Primes seen so far
            int primeCount = 0;
            // buffer for randomly generated bytes
            byte[] randomBuffer = new byte[sizeof(UInt64)];

            switch (options.Algorithm)
            {
                case PrimalityAlgorithm.BruteForce:
                    backupAlgorithm = PrimalityAlgorithmFactory.CreateBruteForceAlgorithm(primeTable.MaxPrimeKnown);
                    break;
                case PrimalityAlgorithm.MillerRabin:
                    backupAlgorithm = PrimalityAlgorithmFactory.CreateMillerRabinAlgorithm();
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            // The combined algorithm (pre-generated table followed by backupAlgorithm)
            IPrimalityTest lookupPlusAlgorithm = new PrecomputedTablePrimalityTest(backupAlgorithm, primeTable);

            // Begin timing
            DateTime now = DateTime.UtcNow;

            for (int i = 0; i < options.SampleSize; i++)
            {
                Rnd.NextBytes(randomBuffer);
                // Using modulo this way is bogus because it throws away the randomness from the upper bits,
                // but it's ok for this example, as we're merely generating load to demonstrate the profiler.
                ulong candidate = BitConverter.ToUInt64(randomBuffer, 0) % options.MaxRandom + 1; // +1 for non-zero

                if (lookupPlusAlgorithm.IsPrime(candidate))
                    primeCount++;
            }

            return new ResultSet
                                   {
                                       Duration = DateTime.UtcNow - now,
                                       PrimeCount = primeCount,
                                       PrimePercentage = (double) primeCount/options.SampleSize,
                                       SampleSize = options.SampleSize,
                                       MaxRandom = options.MaxRandom,
                                       Algorithm = options.Algorithm.ToString()
                                   };
        }
    }
}